#!/usr/bin/env node

const fs = require('fs');
const { join } = require('path');
const raml = require('raml-1-parser');

const readRaml = require('../src/read-raml');
const { validateSchema } = require('../src/validate');
const { loadConfig } = require('../src/util');
const Output = require('../src/output');
const HttpClient = require('../src/http-client');

const config = loadConfig(fs.readFileSync('./.raml-config.json', 'utf8'));

const env = process.env.NODE_ENV;
let host = `http://localhost:${config.port}`;
if (config.runner && env) {
  host = config.runner[env];
}

const apiJSON = raml.loadApiSync(join(config.raml, config.main), {
  serializeMetadata: false
});
const webApiArr = readRaml.getWebApiArr(apiJSON);
const definitionSchema = readRaml.getDefinitionSchema(apiJSON);
const output = new Output(host);

const getResponseByStatusCode = (code, responses) => {
  let response;
  responses.forEach(resp => {
    if (resp.code === code) {
      response = resp;
    }
  });
  return response;
};

HttpClient.setHost(host);

const send = async (webApi, uriParameters, queryParameter, body) => {
  const beginTime = Date.now();
  try {
    const { data, request, status } = await HttpClient.send(
      webApi,
      uriParameters,
      queryParameter,
      body
    );

    if (!webApi.responses.length) {
      output.push(Output.WARNING, 'No set responses', '', request, beginTime);
      return;
    }

    const resp = getResponseByStatusCode(status, webApi.responses);

    if (!resp) {
      output.push(
        Output.ERROR,
        "Can't find code by responses",
        '',
        request,
        beginTime
      );
      return;
    }

    if (!resp.schema) {
      output.push(Output.SUCCESS, '', '', request, beginTime);
      return;
    }

    try {
      const { valid, message, validInfo } = validateSchema(
        definitionSchema,
        resp.schema,
        data
      );
      const type = valid ? Output.SUCCESS : Output.ERROR;
      output.push(type, message, validInfo, request, beginTime);
    } catch (error) {
      output.push(Output.ERROR, error.message, '', request, beginTime);
    }
  } catch (err) {
    output.push(
      Output.ERROR,
      err.message || err,
      '',
      // eslint-disable-next-line no-underscore-dangle
      { path: webApi.absoluteUri, method: webApi.method },
      beginTime
    );
  }
};

webApiArr.sort(webApi => (webApi.runner ? -1 : 1));

const sendRunner = async () => {
  const webApi = webApiArr.shift();
  if (!webApi.runner) {
    webApiArr.unshift(webApi);
    webApiArr.forEach(aa => {
      const body = aa.body ? aa.body.value : {};
      send(aa, aa.uriParameters, aa.queryParameter, body);
    });
    return;
  }
  const body = webApi.body ? webApi.body.value : {};
  await send(webApi, webApi.uriParameters, webApi.queryParameter, body);
  sendRunner();
};

sendRunner();

process.on('beforeExit', () => {
  output.print();
});
